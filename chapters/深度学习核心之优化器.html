<!DOCTYPE HTML>
<html lang="zh-hans">
<head>
<meta charset="utf-8"/>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<title>深度学习核心之优化器.md · 深度学习相关学习记录</title>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="深度学习核心之优化器" name="description"/>
<meta content="GitBook 3.2.3" name="generator"/>
<meta content="narutohyc" name="author"/>
<link href="../gitbook/style.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-splitter/splitter.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-anchors/plugin.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-donate/plugin.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-anchor-navigation-ex/style/plugin.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-mermaid-gb3/mermaid/mermaid.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-tbfed-pagefooter/footer.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-code/plugin.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-search-plus/search.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-lightbox/css/lightbox.min.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-pageview-count/plugin.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-highlight/website.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-fontsettings/website.css" rel="stylesheet"/>
<link href="../gitbook/gitbook-plugin-theme-comscore/test.css" rel="stylesheet"/>
<meta content="true" name="HandheldFriendly"/>
<meta content="width=device-width, initial-scale=1, user-scalable=no" name="viewport"/>
<meta content="yes" name="apple-mobile-web-app-capable"/>
<meta content="black" name="apple-mobile-web-app-status-bar-style"/>
<link href="../gitbook/images/apple-touch-icon-precomposed-152.png" rel="apple-touch-icon-precomposed" sizes="152x152"/>
<link href="../gitbook/images/favicon.ico" rel="shortcut icon" type="image/x-icon"/>
<link href="深度学习核心之损失函数.html" rel="next"/>
<link href="数据标注工具.html" rel="prev"/>
<link href="./chapters/res/other/favicon.ico" rel="shortcut icon" type="image/x-icon"/>
<link href="./chapters/res/other/favicon.ico" rel="apple-touch-icon-precomposed" sizes="152x152"/>
<style>
    @media only screen and (max-width: 640px) {
        .book-header .hidden-mobile {
            display: none;
        }
    }
    </style>
<script>
        window["gitbook-plugin-github-buttons"] = {"buttons":[{"user":"hycBook","repo":"bk_dl_page","type":"star","size":"small","count":true}]};
    </script>
</head>
<body>
          <div class="mountain_a"></div>
          <div class="mountain_b"></div>
          <div class="house right">
            <div class="fence"></div>
            <div class="wall"></div>
            <div class="roof left"></div>
            <div class="roof right"></div>
            <div class="door"></div>
          </div>
          <div class="house left">
            <div class="fence"></div>
            <div class="wall"></div>
            <div class="roof left"></div>
            <div class="roof right"></div>
            <div class="door"></div>
          </div>
          <div class="tree_back"></div>
          <div class="tree"></div>
          <div class="postbox_a">
            <div class="hole"></div>
          </div>
          <div class="postbox_b">
            <div class="hole"></div>
          </div>
          <div class="windmill">
            <div class="tower"></div>
            <div class="t1"></div>
            <div class="t2"></div>
            <div class="blade">
              <div class="windblade"></div>
              <div class="windblade windblade2"></div>
              <div class="windblade windblade3"></div>
              <div class="windblade windblade4"></div>
            </div>
          </div>
          <div class="allsnows">
            <div class="snow1"></div>
            <div class="snow2"></div>
            <div class="snow3"></div>
            <div class="snow4"></div>
            <div class="snow5"></div>
            <div class="snow6"></div>
            <div class="snow7"></div>
            <div class="snow8"></div>
            <div class="snow9"></div>
            <div class="snow10"></div>
            <div class="snow11"></div>
            <div class="snow12"></div>
            <div class="snow13"></div>
            <div class="snow14"></div>
            <div class="snow15"></div>
            <div class="snow16"></div>
            <div class="snow17"></div>
            <div class="snow18"></div>
            <div class="snow19"></div>
            <div class="snow20"></div>
          </div>
          <div class="ground">
            <div class="g1"></div>
            <div class="g2"></div>
            <div class="g3"></div>
            <div class="ice">
              <div class="glare"></div>
              <div class="ice_shadow"></div>
            </div>

          </div>
    
<div class="book">
<div class="book-summary">
<div id="book-search-input" role="search">
<input placeholder="输入并搜索" type="text"/>
</div>
<nav role="navigation">
<ul class="summary">
<li>
<a class="custom-link" href="https://study.hycbook.com" target="_blank">书籍主页</a>
</li>
<li class="divider"></li>
<li class="chapter" data-level="1.1" data-path="../" id="chapter_id_0">
<a href="../">
<b>1.1.</b>
                    
                    Introduction
            
                </a>
</li>
<li class="chapter" data-level="1.2" data-path="LLM模型微调系列.html" id="chapter_id_1">
<a href="LLM模型微调系列.html">
<b>1.2.</b>
                    
                    LLM模型微调系列.md
            
                </a>
</li>
<li class="chapter" data-level="1.3" data-path="LLM模型部署调试推理.html" id="chapter_id_2">
<a href="LLM模型部署调试推理.html">
<b>1.3.</b>
                    
                    LLM模型部署调试推理.md
            
                </a>
</li>
<li class="chapter" data-level="1.4" data-path="dl_in_vision_field.html" id="chapter_id_3">
<a href="dl_in_vision_field.html">
<b>1.4.</b>
                    
                    dl_in_vision_field.md
            
                </a>
</li>
<li class="chapter" data-level="1.5" data-path="huggingface基本使用教程.html" id="chapter_id_4">
<a href="huggingface基本使用教程.html">
<b>1.5.</b>
                    
                    huggingface基本使用教程.md
            
                </a>
</li>
<li class="chapter" data-level="1.6" data-path="nlp关键词和摘要提取技术整理.html" id="chapter_id_5">
<a href="nlp关键词和摘要提取技术整理.html">
<b>1.6.</b>
                    
                    nlp关键词和摘要提取技术整理.md
            
                </a>
</li>
<li class="chapter" data-level="1.7" data-path="pytorch学习.html" id="chapter_id_6">
<a href="pytorch学习.html">
<b>1.7.</b>
                    
                    pytorch学习.md
            
                </a>
</li>
<li class="chapter" data-level="1.8" data-path="transformer.html" id="chapter_id_7">
<a href="transformer.html">
<b>1.8.</b>
                    
                    transformer.md
            
                </a>
</li>
<li class="chapter" data-level="1.9" data-path="图像分割算法.html" id="chapter_id_8">
<a href="图像分割算法.html">
<b>1.9.</b>
                    
                    图像分割算法.md
            
                </a>
</li>
<li class="chapter" data-level="1.10" data-path="图像分类算法.html" id="chapter_id_9">
<a href="图像分类算法.html">
<b>1.10.</b>
                    
                    图像分类算法.md
            
                </a>
</li>
<li class="chapter" data-level="1.11" data-path="图神经网络.html" id="chapter_id_10">
<a href="图神经网络.html">
<b>1.11.</b>
                    
                    图神经网络.md
            
                </a>
</li>
<li class="chapter" data-level="1.12" data-path="数据标注工具.html" id="chapter_id_11">
<a href="数据标注工具.html">
<b>1.12.</b>
                    
                    数据标注工具.md
            
                </a>
</li>
<li class="chapter active" data-level="1.13" data-path="深度学习核心之优化器.html" id="chapter_id_12">
<a href="深度学习核心之优化器.html">
<b>1.13.</b>
                    
                    深度学习核心之优化器.md
            
                </a>
</li>
<li class="chapter" data-level="1.14" data-path="深度学习核心之损失函数.html" id="chapter_id_13">
<a href="深度学习核心之损失函数.html">
<b>1.14.</b>
                    
                    深度学习核心之损失函数.md
            
                </a>
</li>
<li class="chapter" data-level="1.15" data-path="深度学习核心之激活函数.html" id="chapter_id_14">
<a href="深度学习核心之激活函数.html">
<b>1.15.</b>
                    
                    深度学习核心之激活函数.md
            
                </a>
</li>
<li class="chapter" data-level="1.16" data-path="深度学习核心基础知识点.html" id="chapter_id_15">
<a href="深度学习核心基础知识点.html">
<b>1.16.</b>
                    
                    深度学习核心基础知识点.md
            
                </a>
</li>
<li class="chapter" data-level="1.17" data-path="深度学习模型压缩技术.html" id="chapter_id_16">
<a href="深度学习模型压缩技术.html">
<b>1.17.</b>
                    
                    深度学习模型压缩技术.md
            
                </a>
</li>
<li class="chapter" data-level="1.18" data-path="目标检测与跟踪算法.html" id="chapter_id_17">
<a href="目标检测与跟踪算法.html">
<b>1.18.</b>
                    
                    目标检测与跟踪算法.md
            
                </a>
</li>
<li class="divider"></li>
<li>
<a class="gitbook-link" href="https://www.gitbook.com" target="blank">
            本书使用 GitBook 发布
        </a>
</li>
</ul>
</nav>
</div>
<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">
<!-- Title -->
<h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href="..">深度学习核心之优化器.md</a>
</h1>
</div>
<div class="page-wrapper" role="main" tabindex="-1">
<div class="page-inner">
<div class="search-plus" id="book-search-results">
<div class="search-noresults">
<section class="normal markdown-section">
<div id="anchor-navigation-ex-navbar"><i class="fa fa-navicon"></i><ul><li><span class="title-icon"></span><a href="#优化算法">1 优化算法</a></li><ul><li><span class="title-icon"></span><a href="#概述">1.1 概述</a></li><li><span class="title-icon"></span><a href="#基本的梯度下降法">1.2 基本的梯度下降法</a></li><ul><li><span class="title-icon"></span><a href="#bgd">1.2.1 BGD</a></li><li><span class="title-icon"></span><a href="#sgd">1.2.2 SGD</a></li><li><span class="title-icon"></span><a href="#mbgd">1.2.3 MBGD</a></li></ul><li><span class="title-icon"></span><a href="#动量优化法">1.3 动量优化法</a></li><ul><li><span class="title-icon"></span><a href="#sgdm">1.3.1 SGDM</a></li><li><span class="title-icon"></span><a href="#nag">1.3.2 NAG</a></li></ul><li><span class="title-icon"></span><a href="#自适应学习率优化器">1.4 自适应学习率优化器</a></li><ul><li><span class="title-icon"></span><a href="#adagrad">1.4.1 AdaGrad</a></li><li><span class="title-icon"></span><a href="#rmsprop">1.4.2 RMSProp</a></li><li><span class="title-icon"></span><a href="#adadelta">1.4.3 Adadelta</a></li><li><span class="title-icon"></span><a href="#adam">1.4.4 Adam</a></li><li><span class="title-icon"></span><a href="#adamax">1.4.5 AdaMax</a></li><li><span class="title-icon"></span><a href="#nadam">1.4.6 Nadam</a></li><li><span class="title-icon"></span><a href="#其他优化器">1.4.7 其他优化器</a></li></ul></ul><li><span class="title-icon"></span><a href="#学习率衰减">2 学习率衰减</a></li></ul></div><a href="#优化算法" id="anchorNavigationExGoTop"><i class="fa fa-arrow-up"></i></a><hr/>
<h1 id="优化算法">1 优化算法</h1>
<p>最优化是指<code>非线性最优化</code>，解非线性最优化的方法有很多</p>
<p>比如<code>梯度下降法</code>、<code>共轭梯度法</code>、<code>变尺度法</code>和<code>步长加速</code>法等</p>
<p>参考本站链接<a href="https://hycbook.com/article/58730.html" target="_blank">机器学习_最优化方法</a></p>
<p><a data-lightbox="10e9f804-342f-4d1d-baed-9f213e7f2559" data-title="优化器之间的关系脉络" href="https://pic.hycbook.com/i/hexo/bk_resources/deep_learning/深度学习核心之优化器/优化器之间的关系脉络.svg" target="_blank"><img alt="优化器之间的关系脉络" src="https://pic.hycbook.com/i/hexo/bk_resources/deep_learning/深度学习核心之优化器/优化器之间的关系脉络.svg"/></a></p>
<h2 id="概述">1.1 概述</h2>
<blockquote>
<p><a href="https://pytorch.org/docs/stable/optim.html" target="_blank">pytorch优化器</a></p>
<p><a href="https://paddlepedia.readthedocs.io/en/latest/tutorials/deep_learning/optimizers/gd.html" target="_blank">飞浆官方文档，总结到位</a></p>
<p><a href="https://www.hanspub.org/journal/PaperInformation.aspx?paperID=27016&amp;btwaf=50696508" target="_blank">深度学习优化器方法及学习率衰减方式综述</a></p>
<p><a href="https://arxiv.org/pdf/1609.04747.pdf" target="_blank">An overview of gradient descent optimization algorithms</a></p>
</blockquote>
<table>
<thead>
<tr>
<th>1847</th>
<th>1951</th>
<th>1983</th>
<th>2011</th>
<th>2012</th>
</tr>
</thead>
<tbody>
<tr>
<td>GD(BGD)</td>
<td>SGD</td>
<td>SGDM(Momentum)、NAG</td>
<td>AdaGrad</td>
<td>Adadelta、RMSprop</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>2015</th>
<th>2016</th>
<th>2018</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Adam、AdaMax</td>
<td>Nadam</td>
<td>AMSGrad</td>
</tr>
</tbody>
</table>
<blockquote>
<p>相对应的论文</p>
</blockquote>
<p><a href="http://ieeexplore.ieee.org/iel5/21/4308307/04308316.pdf" target="_blank">A Stochastic Approximation Method SGD 1951</a></p>
<p><a href="http://www.iro.umontreal.ca/~pift6266/A06/refs/backprop_old.pdf" target="_blank">Learning representations by back-propagating errors Momentum 1983</a></p>
<p><a href="https://www.researchgate.net/publication/260365606_A_method_for_unconstrained_convex_minimization_problem_with_the_rate_of_convergence" target="_blank">A method for unconstrained convex minimization problem with the rate of convergence  o(1/k2) NAG 1983</a></p>
<p><a href="https://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=02923576939D50A9A51E4BE7500CF493?doi=10.1.1.232.4000&amp;rep=rep1&amp;type=pdf" target="_blank">Adaptive subgradient methods for online learning and stochastic optimization AdaGrad 2011</a></p>
<p><a href="https://arxiv.org/pdf/1212.5701.pdf" target="_blank">ADADELTA: an adaptive learning rate method. Adadelta 2012</a></p>
<p><a href="https://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf" target="_blank">Neural Networks for Machine Learning Lecture 6a Overview of mini-batch gradient descent RMSprop 2012</a></p>
<p><a href="https://arxiv.org/pdf/1412.6980.pdf" target="_blank">Adam: A method for stochastic optimization Adam &amp; AdaMax 2014</a></p>
<p><a href="https://openreview.net/pdf?id=OM0jvwB8jIp57ZJjtNEZ" target="_blank">Incorporating Nesterov Momentum into Adam NAdam 2016</a></p>
<p>以下是优化器的发展脉络，按照时间顺序列出了一些重要的优化器及其年份：</p>
<ol>
<li><p>Gradient Descent (GD)：最早的优化器之一，用于求解无约束优化问题。没有特定的年份，但早在20世纪50年代就开始被广泛应用</p>
</li>
<li><p>Stochastic Gradient Descent (SGD)：引入随机性来估计梯度的优化器，用于大规模数据集和深度学习模型。没有特定的年份，但在深度学习的早期就被广泛使用</p>
</li>
<li><p>Momentum（1983）：提出了动量概念，通过累积梯度的指数加权平均来加速收敛</p>
</li>
<li><p>AdaGrad（2011）：自适应梯度算法，通过对梯度进行归一化和调整学习率，适应不同参数的更新需求</p>
</li>
<li><p>Adadelta（2012）：改进了AdaGrad的缺点，通过考虑历史梯度的平均值来调整学习率</p>
<p>RMSprop（2012）：引入了指数加权移动平均的概念，用于调整学习率以平衡历史梯度信息</p>
</li>
<li><p>Adam（2014）：结合了动量和自适应学习率的优点，通过自适应调整学习率和梯度的一阶矩估计和二阶矩估计来进行参数更新</p>
<p>AdaMax（2014）：基于Adam算法，通过替换二阶矩估计的范数为无穷范数，提供了更稳定的更新规则</p>
</li>
<li><p>Nadam（2016）：结合了Nesterov动量和Adam算法，利用动量来加速收敛</p>
</li>
<li><p>AMSGrad（2018）：对Adam算法进行了改进，解决了Adam算法学习率下降不稳定的问题</p>
</li>
</ol>
<p>这些是一些比较重要的优化器，并且按照时间顺序列出。然而，需要注意的是，并非所有的优化器都是线性发展的，而是相互借鉴、改进和结合的结果。优化器的发展是一个活跃的研究领域，仍然有许多新的优化算法被提出和改进</p>
<blockquote>
<p>什么是优化器</p>
</blockquote>
<p>深度学习的目标是通过不断改变网络参数，使得参数能够对输入做各种非线性变换拟合输出，本质上就是一个函数去寻找最优解，所以<code>如何去更新参数</code>是深度学习研究的重点</p>
<p>通常将更新参数的算法称为<code>优化器</code>，字面理解就是通过什么算法去优化网络模型的参数</p>
<blockquote>
<p>梯度下降核心点</p>
</blockquote>
<ol>
<li><strong>方向</strong>: 确定优化的方向，一般通过求导便可以求得</li>
<li><strong>步长</strong>: 步子就是决定当前走多大，如果学习率设的过大，梯度会在最优点来回跳动，设的过小需要很久的训练才能达到最优点</li>
</ol>
<blockquote>
<p>优化器的主要作用</p>
</blockquote>
<ol>
<li><strong>参数更新</strong>：优化器根据损失函数的梯度信息，计算出每个参数的更新量，并将更新量应用于参数，从而更新模型的参数。这样，模型的参数就可以朝着能够更好地拟合训练数据的方向进行调整</li>
<li><strong>学习率调整</strong>：优化器通常会自动调整学习率，以控制参数更新的步幅。学习率决定了每次参数更新的幅度，过大的学习率可能导致参数更新过快而错过最优解，而过小的学习率可能导致收敛速度缓慢。优化器根据当前训练的进度和参数的变化情况，动态地调整学习率，以获得更好的训练效果</li>
<li><strong>优化算法选择</strong>：优化器提供了多种不同的优化算法，如梯度下降、动量优化、自适应学习率等。这些算法在参数更新的方式、学习率调整策略等方面有所不同，可以根据具体任务的需求选择合适的优化算法</li>
</ol>
<p>通过合适的优化器选择和参数调整，可以提高神经网络的训练效率和性能，加速收敛过程，使得模型能够更好地拟合训练数据，并在测试数据上取得较好的泛化能力</p>
<blockquote>
<p>优化器分类</p>
</blockquote>
<ol>
<li><strong>梯度下降优化器(Gradient Descent Optimizers)</strong>：基于梯度信息来更新参数的优化器，包括批量梯度下降(BGD)、随机梯度下降(SGD)和小批量梯度下降(Mini-Batch Gradient Descent，MBGD)等</li>
<li><strong>基于动量的优化器(Momentum-based Optimizers)</strong>：在梯度下降的基础上引入动量的概念，旨在加速收敛过程并减少震荡，常见的包括动量优化器(Momentum Optimizer)、牛顿加速度动量优化法Nesterov Accelerated Gradient(NAG)等</li>
<li><strong>自适应学习率优化器(Adaptive Learning Rate Optimizers)</strong>：根据参数更新的情况动态地调整学习率，以提高收敛速度和效果，常见的包括AdaGrad、RMSprop、Adam、AdaDelta、Adamax等</li>
<li><strong>学习率衰减优化器(Learning Rate Decay Optimizers)</strong>：在训练过程中逐渐减小学习率的优化器，常见的包括Step Decay、Exponential Decay、Piecewise Decay等</li>
<li><strong>正则化优化器(Regularization Optimizers)</strong>：结合正则化技术，通过对损失函数添加正则化项来控制模型的复杂度，常见的包括L1正则化、L2正则化等</li>
<li><strong>二阶优化器(Second-Order Optimizers)</strong>：考虑参数二阶信息的优化器，如牛顿法(Newton's Method)、共轭梯度法(Conjugate Gradient)等</li>
</ol>
<p>不同类型的优化器在更新参数的方式、学习率调整策略、收敛速度、对噪声和局部最优的鲁棒性等方面有所区别，选择合适的优化器取决于具体的问题和数据集特征</p>
<h2 id="基本的梯度下降法">1.2 基本的梯度下降法</h2>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/584485233" target="_blank">优化器综述</a></p>
<p><a href="https://www.cnblogs.com/guoyaohua/p/8542554.html" target="_blank">深度学习——优化器算法Optimizer详解（BGD、SGD、MBGD、Momentum、NAG、Adagrad、Adadelta、RMSprop、Adam）</a></p>
</blockquote>
<p>优化器的存在就是确定优化的方向和面对当前的情况动态的调整步子</p>
<blockquote>
<p>BGD、SGD和MBGD的区别</p>
</blockquote>
<table>
<thead>
<tr>
<th>优化器</th>
<th>BGD</th>
<th>SGD</th>
<th>MBGD</th>
</tr>
</thead>
<tbody>
<tr>
<td>样本数</td>
<td>N(所有)</td>
<td>1</td>
<td>batch_size</td>
</tr>
</tbody>
</table>
<h3 id="bgd">1.2.1 BGD</h3>
<p><code>BGD(Batch Gradient Descent)</code>采用<strong>整个训练集</strong>的数据来计算cost function对参数的梯度
<script type="math/tex; mode=display">
w_{t+1}=w_{t}-\alpha \Delta L\left(w_{t}\right)
</script>
其中<script type="math/tex; ">\alpha </script>为学习率，而<script type="math/tex; ">\Delta L\left(w_{t}\right)</script>为损失函数的一阶导数</p>
<blockquote>
<p>BGD在计算梯度时会出现冗余</p>
</blockquote>
<p>因为BGD在每一次迭代中都使用了整个训练集，而且在梯度计算过程中并没有考虑样本之间的相关性</p>
<p>因此，对于样本中的某些部分，其梯度计算可能会与其他样本的梯度计算重复，这种冗余计算可能会导致计算效率的降低，特别是在训练集很大的情况下</p>
<blockquote>
<p>优点</p>
</blockquote>
<ol>
<li><strong>收敛稳定</strong>：由于每次迭代使用整个训练集的所有样本进行参数更新，收敛过程相对稳定</li>
<li><strong>参数更新准确</strong>：使用全局梯度来更新参数，对于<strong>凸优化问题，可以达到全局最优解</strong></li>
</ol>
<blockquote>
<p>缺点</p>
</blockquote>
<ol>
<li><strong>训练速度慢</strong>：BGD 是一种批量梯度下降算法，每次更新模型参数时使用整个训练数据集</li>
<li><strong>计算开销大</strong>：需要计算整个训练集的梯度，对于大规模数据集或复杂模型，计算开销较高</li>
<li><strong>内存占用高</strong>：需要存储整个训练集的数据和梯度信息</li>
</ol>
<h3 id="sgd">1.2.2 SGD</h3>
<p><code>SGD(Stochastic Gradient Descent)</code>是一种随机梯度下降算法，每次更新模型参数时使用<strong>单个样本</strong>或<strong>一小批样本</strong>(通常称为mini-batch，也称MBGD)
<script type="math/tex; mode=display">
w_{t+1}=w_{t}-\alpha \frac{1}{m} \sum_{i=1}^{m} \Delta L\left(w_{i}\right)
</script>
其中<script type="math/tex; ">\alpha </script>为学习率，而<script type="math/tex; ">\Delta L\left(w_{t}\right)</script>为损失函数的一阶导数，<script type="math/tex; ">m</script>为batch_size，当<script type="math/tex; ">m=1</script>就是SGD，否则就是MBGD</p>
<blockquote>
<p>优点</p>
</blockquote>
<ol>
<li><strong>计算开销小</strong>：每次迭代只使用<strong>一个样本</strong>进行参数更新，计算开销较小</li>
<li><strong>适用于大规模数据集</strong>：由于样本的随机选择，可以处理大规模数据集，且易于并行处理</li>
</ol>
<blockquote>
<p>缺点</p>
</blockquote>
<ol>
<li><strong>参数更新不稳定</strong>：由于单个样本的梯度计算可能<strong>存在噪声</strong>，参数更新不稳定，可能引起参数在最优点附近震荡</li>
<li><strong>收敛速度较慢</strong>：由于参数更新的不稳定性，收敛速度相对较慢</li>
</ol>
<h3 id="mbgd">1.2.3 MBGD</h3>
<p><code>MBGD(Mini-Batch Gradient Descent)</code>每一次利用一小批样本，即batch_size个样本进行计算，这样它可以降低参数更新时的方差，收敛更稳定，另一方面可以充分地利用深度学习库中高度优化的矩阵操作来进行更有效的梯度计算
<script type="math/tex; mode=display">
w_{t+1}=w_{t}-\alpha \frac{1}{m} \sum_{i=1}^{m} \Delta L\left(w_{i}\right)
</script>
其中<script type="math/tex; ">\alpha </script>为学习率，而<script type="math/tex; ">\Delta L\left(w_{t}\right)</script>为损失函数的一阶导数，<script type="math/tex; ">m</script>为batch_size，当<script type="math/tex; ">m=1</script>就是SGD，否则就是MBGD</p>
<blockquote>
<p>优点</p>
</blockquote>
<ol>
<li><strong>平衡了开销和参数稳定性</strong>：使用一小批样本进行参数更新，综合了全局梯度和随机梯度的信息，计算开销和参数更新的稳定性得到一定的平衡</li>
<li><strong>收敛速度较快</strong>：相对于BGD，使用较小的批量样本更新参数，收敛速度更快</li>
</ol>
<blockquote>
<p>缺点</p>
</blockquote>
<ol>
<li><strong>批量大小需调优</strong>：批量大小的选择可能会影响模型的性能，需要进行调优</li>
<li><strong>可能导致局部最优</strong>：较小的批量样本可能会引入一定的随机性，可能导致陷入局部最优而无法达到全局最优</li>
</ol>
<h2 id="动量优化法">1.3 动量优化法</h2>
<h3 id="sgdm">1.3.1 SGDM</h3>
<p>随机梯度下降法虽然有效，但容易陷入局部最小值点，甚至在驻点附近以及梯度值非常小的点附近时参数更新极为缓慢</p>
<p>为了抑制SGD的震荡，<code>SGDM(Stochastic Gradient Descent Momentum)</code>认为梯度下降过程可以加入惯性</p>
<p>主要思想是下降过程中，如果发现是陡坡，那就利用惯性跑的快一些。因此，其在SGD基础上引入了一阶动量</p>
<p>在坡度比较陡的地方，会有较大的惯性，这是下降的多。坡度平缓的地方，惯性较小，下降的会比较慢
<script type="math/tex; mode=display">
\begin{array}{c}
m_{t}=\lambda m_{t-1}+ \alpha \Delta L(w_t) \\
w_{t+1}=w_{t}-m_{t}
\end{array}
</script>
其中<script type="math/tex; ">\alpha </script>为学习率，<script type="math/tex; ">\Delta L(w_t)</script>表示当前t时刻梯度，<script type="math/tex; ">m_t</script>表示当前时刻的加权后的梯度，<script type="math/tex; ">\lambda</script>是<code>动量系数</code></p>
<p><script type="math/tex; ">\lambda</script>的经验值为0.9(表示最大速度10倍于SGD)，这就意味着下降方向主要是此前累积的下降方向，并略微偏向当前时刻的下降方向</p>
<p>一阶动量是各个时刻梯度方向的指数移动平均值，也就是说，<script type="math/tex; ">t</script>时刻的下降方向，不仅由当前点的梯度方向<script type="math/tex; ">\Delta L(w_t)</script>决定，而且由此前累积的下降方向<script type="math/tex; ">m_{t-1}</script>决定</p>
<blockquote>
<p>梯度是如何累积的</p>
</blockquote>
<p>这里将<script type="math/tex; ">m_t</script>展开，可以看到<strong>当前时刻的梯度是对历史梯度进行加权得到的</strong>，其中，<script type="math/tex; ">\lambda</script>是一个介于0和1之间的参数，控制了历史梯度对当前动量的贡献程度</p>
<ul>
<li>较大的<script type="math/tex; ">\lambda</script>值会使历史梯度的贡献更大，从而使动量更加平滑</li>
<li>较小的<script type="math/tex; ">\lambda</script>值会使当前梯度的贡献更大，从而对变化更为敏感</li>
</ul>
<p>这种权重衰减的方式使得历史梯度的贡献逐渐减小，更加关注近期的梯度变化，有助于适应变化的数据和模型参数
<script type="math/tex; mode=display">
\begin{aligned}
m_{t}= & -\alpha \Delta L(w_t) -\alpha \lambda \Delta L(w_{t-1})-\alpha \lambda^{2} \Delta L(w_{t-2})-\alpha \lambda^{3} \Delta L(w_{t-3}) \cdots
\end{aligned}
</script></p>
<blockquote>
<p>优点</p>
</blockquote>
<ol>
<li><p><strong>加速收敛</strong>：SGDM引入了动量的概念，通过累积之前的动量信息，有助于加速模型的收敛速度，特别是在存在平坦区域的情况下更为明显</p>
</li>
<li><p><strong>减少震荡</strong>：动量的累积作用可以减少参数更新时的震荡现象，有助于更稳定地更新模型参数</p>
</li>
<li><p><strong>尽可能跳出局部最优</strong>：动量的引入可以帮助模型跳出局部最优点，以便更好地搜索全局最优点</p>
<p>当局部沟壑比较深，动量加持用完了，依然会困在局部最优里来回振荡</p>
</li>
</ol>
<blockquote>
<p>缺点</p>
</blockquote>
<ol>
<li><strong>需要调整超参数</strong>：SGDM中的动量系数需要手动设置，选择合适的动量系数对于模型的性能影响较大，需要进行调试和调优</li>
<li><strong>可能导致过拟合</strong>：当动量系数较大时，SGDM可能在优化过程中过度依赖之前的动量信息，导致模型过拟合</li>
<li><strong>难以处理非平稳数据</strong>：对于非平稳数据，SGDM的动量累积可能会导致模型在变化快速的方向上过度追踪，而无法及时适应变化</li>
</ol>
<blockquote>
<p>改进方法</p>
</blockquote>
<ol>
<li><strong>自适应调整动量系数</strong>：可以采用自适应的方式来调整动量系数，例如使用自适应的动量方法(如Adam)来根据梯度的变化自动调整动量系数</li>
<li><strong>学习率调度策略</strong>：结合学习率调度策略，如<strong>学习率衰减</strong>或<strong>自适应学习率方法</strong>，可以更好地控制模型的学习速度和方向</li>
<li><strong>正则化技术</strong>：使用正则化技术，如L1正则化或L2正则化，可以缓解过拟合问题，使模型更具泛化能力</li>
</ol>
<p>因为加入了动量因素，SGDM缓解了SGD在局部最优点梯度为0，无法持续更新的问题和振荡幅度过大的问题，但是并没有完全解决，当局部沟壑比较深，动量加持用完了，依然会困在局部最优里来回振荡</p>
<h3 id="nag">1.3.2 NAG</h3>
<blockquote>
<p><a href="https://blog.csdn.net/qq_38156104/article/details/106739700" target="_blank">深度学习优化函数详解-- Nesterov accelerated gradient (NAG)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/22810533/" target="_blank">比Momentum更快：揭开Nesterov Accelerated Gradient的真面目</a></p>
</blockquote>
<p>动量法每下降一步都是由前面下降方向的一个累积和当前点的梯度方向组合而成。于是一位大神(Nesterov)就开始思考，既然每一步都要将两个梯度方向(历史梯度、当前梯度)做一个合并再下降，那为什么不先按照历史梯度往前走那么一小步，按照前面一小步位置的<strong>超前梯度</strong>来做梯度合并呢</p>
<p>如此一来，小球就可以先不管三七二十一先往前走一步，在靠前一点的位置看到梯度，然后按照那个位置再来修正这一步的梯度方向，同SGDM比较的差一点如下公式所示
<script type="math/tex; mode=display">
\Delta L(w_{t-1})  \longrightarrow  \Delta L(w_{t-1}-\lambda m_{t-1})
</script></p>
<p>既然知道会走<script type="math/tex; ">\lambda m_{t-1}</script>，就不需要还用当前位置的梯度，可以直接走到<script type="math/tex; ">\lambda m_{t-1}</script>的位置计算梯度，这样子就有了<code>超前眼光</code></p>
<p>有了超前的眼光，小球就会更加<strong>聪明</strong>, 这种方法被命名为<code>牛顿加速梯度(Nesterov accelerated gradient)</code>简称<code>NAG</code>，下图是SGDM下降法与NAG下降法的可视化比较</p>
<p><a data-lightbox="41d65c7f-2b23-471f-802d-4bfc6e4f9be0" data-title="momentum下降法与NAG下降法比较" href="https://pic.hycbook.com/i/hexo/bk_resources/deep_learning/深度学习核心之优化器/momentum下降法与NAG下降法比较.webp" target="_blank"><img alt="momentum下降法与NAG下降法比较" src="https://pic.hycbook.com/i/hexo/bk_resources/deep_learning/深度学习核心之优化器/momentum下降法与NAG下降法比较.webp"/></a></p>
<p>NAG算法公式表达如下：
<script type="math/tex; mode=display">
\begin{array}{c}
m_{t}=\lambda m_{t-1}+ \alpha \Delta L(w_{t-1}-\lambda m_{t-1}) \\
w_{t+1}=w_{t}-m_{t}
\end{array}
</script></p>
<blockquote>
<p>为什么NAG比SGDM快</p>
</blockquote>
<p>对NAG原来的更新公式进行变换，得到这样的等效形式(<a href="https://zhuanlan.zhihu.com/p/22810533/" target="_blank">具体推导过程</a>)
<script type="math/tex; mode=display">
\begin{array}{c}
m_{t}=\lambda m_{t-1}+ \alpha \Delta L(w_{t-1}) + \lambda ( \Delta L(w_{t-1}) - \Delta L(w_{t-2}) )  \\
w_{t+1}=w_{t}-m_{t}
\end{array}
</script>
与Momentum的区别在于，本次更新方向多加了一个<script type="math/tex; ">\lambda ( \Delta L(w_{t-1}) - \Delta L(w_{t-2}) )</script></p>
<p>直观含义就很明显了：如果这次的梯度比上次的梯度变大了，那么有可能会继续变大，可以把预计增大的部分提前加进来；变小的情况类似</p>
<p>这个多加上去的项就是在近似目标函数的二阶导嘛，因此，<code>NAG本质上是多考虑了目标函数的二阶导信息</code>，其实所谓<strong>往前看</strong>的说法，在牛顿法这样的二阶方法中也是经常提到的，从数学角度上看，则是<strong>利用了目标函数的二阶导信息</strong></p>
<h2 id="自适应学习率优化器">1.4 自适应学习率优化器</h2>
<h3 id="adagrad">1.4.1 AdaGrad</h3>
<blockquote>
<p><a href="https://www.cnblogs.com/wry789/p/12988629.html" target="_blank">李宏毅深度学习笔记-Adagrad算法</a></p>
<p><a href="http://faculty.bicmr.pku.edu.cn/~wenzw/optbook/pages/stograd/Adagrad.html" target="_blank">AdaGrad 算法</a></p>
<p>优化的变量对于目标函数的依赖是各不相同</p>
</blockquote>
<p>在基本的梯度下降法优化中，有一个常见的问题是，<code>要优化的变量对于目标函数的依赖是各不相同的</code></p>
<ul>
<li><p>对于某些变量，已经优化到了极小值附近，但是有的变量仍然在梯度很大的地方，这时候一个统一的全局学习率是可能出现问题的</p>
</li>
<li><p>如果学习率太小，则梯度很大的变量会收敛很慢，如果梯度太大，已经优化差不多的变量就可能会不稳定</p>
</li>
</ul>
<p>现实世界的数据集中，一些特征是稀疏的(大部分特征为零，所以它是稀疏的)，而另一些则是密集的(dense，大部分特征是非零的)，因此为所有权值保持相同的学习率不利于优化</p>
<p>针对这个问题，当时在伯克利加州大学读博士的Jhon Duchi，2011年提出了<code>AdaGrad(Adaptive Gradient)</code>，也就是<code>自适应学习率</code></p>
<blockquote>
<p>基本思想</p>
</blockquote>
<p>AdaGrad的基本思想是对每个变量用不同的学习率，设置了全局学习率之后，每次通过，<strong>全局学习率逐参数的除以历史梯度平方和的平方根，使得每个参数的学习率不同</strong></p>
<p>这个学习率在一开始会比较大，用于快速梯度下降。随着优化过程的进行，对于<strong>已经下降很多的变量，则减缓学习率</strong>，对于<strong>还没怎么下降的变量，则保持一个较大的学习率</strong></p>
<blockquote>
<p>公式</p>
</blockquote>
<p><script type="math/tex; mode=display">
w_{t+1} =w_{t}-\frac{\alpha}{\sqrt{G_{t}+\epsilon }} \odot \eta \Delta L(w_t)
</script></p>
<p>其中<script type="math/tex; ">\eta</script>为学习率，而<script type="math/tex; ">\Delta L\left(w_{t}\right)</script>为损失函数的一阶导数，<script type="math/tex; ">\epsilon</script>是一个平滑项，避免了除以零(通常取值在<script type="math/tex; ">1e-8</script>左右)，<script type="math/tex; ">\odot</script>表示元素逐元素相乘操作</p>
<p><script type="math/tex; ">G_{t+1}</script>可以写成下式，每个参数的所有偏微分的平方和，<script type="math/tex; ">g_i</script>是对梯度的缩写</p>
<p><script type="math/tex; mode=display">
G_{t+1} =G_{t}+g_{t+1} \odot g_{t+1} = \sum _{i=0}^{t} { {g_i} ^2 }
</script></p>
<blockquote>
<p>优缺点</p>
</blockquote>
<p><strong>优点</strong>：</p>
<ul>
<li>自适应的学习率，无需人工调节，AdaGrad在迭代过程中不断调整学习率，并让目标函数中的每个参数都分别拥有自己的学习率，学习率默认值为0.01</li>
<li>有效地处理稀疏特征，因为它能够自动调整每个特征的学习率，使得稀疏特征的更新更少</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>全局学习率</strong>: 仍需要手工设置一个全局学习率<script type="math/tex; ">\eta</script>, 如果<script type="math/tex; ">\eta</script>设置过大的话，会使regularizer过于敏感，对梯度的调节太大</li>
<li><strong>训练停止</strong>: 由于梯度平方和的累积，<strong>学习率会不断衰减</strong>，可能导致在训练后期学习率过小，造成收敛速度过慢或者提前停止训练的问题(<code>Adadelta</code>算法解决)</li>
</ul>
<blockquote>
<p>附上别人写的代码</p>
</blockquote>
<pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sgd_adagrad</span><span class="hljs-params">(parameters, sqrs, lr)</span>:</span>
    eps = <span class="hljs-number">1e-10</span>
    <span class="hljs-keyword">for</span> param, sqr <span class="hljs-keyword">in</span> zip(parameters, sqrs):
        sqr[:] = sqr + param.grad.data ** <span class="hljs-number">2</span>
        div = lr / torch.sqrt(sqr + eps) * param.grad.data
        param.data = param.data - div
</code></pre>
<h3 id="rmsprop">1.4.2 RMSProp</h3>
<blockquote>
<p><a href="https://arxiv.org/pdf/1609.04747.pdf" target="_blank">An overview of gradient descent optimization algorithms 2017</a></p>
</blockquote>
<p><code>RMSProp(Root Mean Square Propagation)</code>是Hinton大神于2012年在一门叫<a href="https://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf" target="_blank">Neural Networks for Machine Learning</a>的在线课程中提出(并未正式发表)，是梯度下降优化算法的扩展</p>
<p><code>RMSProp实际上是Adagrad引入了Momentum</code>，公式表达如下所示
<script type="math/tex; mode=display">
\begin{array}{c}
G_{t+1} = \beta G_t + (1-\beta) \Delta L (w_{t})^2
\\
w_{t+1} = w_t -  \frac {\alpha}{\sqrt{ G_{t} + \epsilon }} \odot \Delta L (w_t)
\end{array}
</script>
<script type="math/tex; ">\alpha</script>是学习率，<script type="math/tex; ">\beta</script>则类似于动量梯度下降法中的衰减因子，代表过去梯度对当前梯度的影响，一般取值0.9，<script type="math/tex; ">\epsilon</script>是一个平滑项，避免了除以零(通常取值在<script type="math/tex; ">1e-8</script>左右)，<script type="math/tex; ">\odot</script>表示元素逐元素相乘操作(也可以省略不写)</p>
<p>公式里的<code>累积梯度平方和</code><script type="math/tex; ">G_{t+1}</script>可以展开写成下面的形式，<script type="math/tex; ">g_i</script>是对梯度的缩写(同AdaGrad)
<script type="math/tex; mode=display">
G_{t+1} = \beta G_t + (1-\beta) \sum _{i=0}^{t} { {g_i} ^2 }
</script></p>
<blockquote>
<p>优点</p>
<p>缺点</p>
<p>代码(<a href="https://towardsdatascience.com/understanding-rmsprop-faster-neural-network-learning-62e116fcf29a" target="_blank">参考文档</a>)</p>
</blockquote>
<pre><code class="lang-python">drad_squared = <span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> num_iterations:
    dw = compute_gradients(x, y)
    grad_squared = <span class="hljs-number">0.9</span> * grads_squared + <span class="hljs-number">0.1</span> * dx * dx
    w = w - (lr / np.sqrt(grad_squared)) * dw
</code></pre>
<h3 id="adadelta">1.4.3 Adadelta</h3>
<blockquote>
<p><a href="https://betheme.net/news/txtlist_i150611v.html?action=onClick" target="_blank">优化器(AdaGrad,AdaDelta,RmsProp,Adam,Nadam,Nesterovs,Sgd,momentum)</a></p>
<p><a href="https://blog.csdn.net/XiangJiaoJun_/article/details/83960136" target="_blank">AdaDelta算法两种解决方案</a></p>
<p><a href="https://gmis.jiqizhixin.com/graph/technologies/173c1ba6-0a13-45f6-9374-ec0389124832" target="_blank">Adadelta 优化器</a></p>
</blockquote>
<p>由于AdaGrad调整学习率变化过于激进，我们考虑一个改变二阶动量计算方法的策略：<strong>不累积全部历史梯度，而只关注过去一段时间窗口的下降梯度</strong></p>
<p>即Adadelta只累加固定大小的项，并且也不直接存储这些项，仅仅是近似计算对应的平均值(指数移动平均值)，这就避免了二阶动量持续累积、导致训练过程提前结束的问题了</p>
<p>论文中提到了两种实现策略</p>
<blockquote>
<p>方法一: Accumulate Over Window</p>
</blockquote>
<p>从全部历史梯度变为当前时间向前的一个窗口期内的累积，计算定义为
<script type="math/tex; mode=display">
\mathrm{E}\left[\mathrm{g}^{2}\right]_{\mathrm{t}}=\rho * \mathrm{E}\left[\mathrm{g}^{2}\right]_{\mathrm{t}-1}+(1-\rho) * \mathrm{~g}_{\mathrm{t}}^{2}
</script>
相当于历史梯度信息的累计乘上一个衰减系数<script type="math/tex; ">\rho</script>，然后用<script type="math/tex; ">\rho</script>作为当前梯度的平方加权系数相加</p>
<p>梯度更新公式为
<script type="math/tex; mode=display">
\mathrm{w}_{\mathrm{t+1}}=\mathrm{w}_{\mathrm{t}}-\frac{\eta}{\sqrt{\mathrm{E}\left[\mathrm{g}^{2}\right]_{\mathrm{t}}+\epsilon}} * \mathrm{~g}_{\mathrm{t}}
</script>
解决了对历史梯度一直累加而导致学习率一直下降的问题</p>
<blockquote>
<p>方法二: <a href="https://arxiv.org/pdf/1212.5701.pdf" target="_blank">Correct Units with Hessian Approximation</a></p>
</blockquote>
<p>在1988年LeCun等人曾经提出一种用矩阵对角线元素来近似逆矩阵
<script type="math/tex; mode=display">
\Delta x_{t}=-\frac{1}{\left|\operatorname{diag}\left(H_{t}\right)\right|+\mu} g_{t}
</script>
diag函数指的是构造Hessian矩阵的对角矩阵，<script type="math/tex; ">\mu</script>是常数项，防止分母为0</p>
<p>如果学过数值分析的同学应该知道，<strong>牛顿法用Hessian矩阵替代人工设置的学习率</strong>，在梯度下降的时候，可以完美的找出下降方向，不会陷入局部最小值当中，是理想的方法，但是<strong>Hessian矩阵的逆在数据很大的情况下根本没办法求</strong></p>
<p>2012年，[Schaul&amp;S. Zhang&amp;LeCun]借鉴了AdaGrad的做法，提出了更精确的近似
<script type="math/tex; mode=display">
\Delta x_{t}=-\frac{1}{\left|\operatorname{diag}\left(H_{t}\right)\right|} \frac{E\left[g_{t-w: t}\right]^{2}}{E\left[g_{t-w: t}^{2}\right]} g_{t}
</script>
<script type="math/tex; ">E\left[g_{t-w: t}\right]</script>指的是从当前t开始的前w个梯度状态的期望值</p>
<p><script type="math/tex; ">E\left[g_{t-w: t}^{2}\right]</script>指的是从当前t开始的前w个梯度状态的<strong>平方</strong>的期望值</p>
<p>同样是基于Gradient的Regularizer，不过<strong>只取最近的w个状态</strong>，这样不会让梯度被惩罚至0</p>
<p>这里如果求期望的话，非常的麻烦，所以采取了移动平均法来计算。这里作者在论文中也给出了近似的证明
<script type="math/tex; mode=display">
\Delta \mathrm{x} \propto \mathrm{g} \propto \frac{\mathrm{df}}{\mathrm{dx}} \propto \frac{1}{x}
</script>
这里是当为指数型函数, 最后一个近似成立。 对于牛顿法：
<script type="math/tex; mode=display">
\Delta \mathrm{x} \propto H^{-1} \mathrm{~g} \propto \frac{\frac{\mathrm{df}}{\mathrm{dx}}}{\frac{\partial^{2} f}{\partial x^{2}}}
</script>
由上式可得：
<script type="math/tex; mode=display">
\frac{\frac{d f}{d x}}{\frac{\partial^{2} f}{\partial x^{2}}}=\frac{1}{\frac{\partial^{2} f}{\partial x^{2}}} g_{t}
</script>
基中:
<script type="math/tex; mode=display">
\frac{\frac{d f}{d x}}{\frac{\partial^{2} f}{\partial x^{2}}}=\frac{1}{\frac{\partial^{2} f}{\partial x^{2}}} g_{t}
</script>
这里可以用局部的加权指数平滑来替代，即：
<script type="math/tex; mode=display">
\frac{\Delta x}{\frac{\partial f}{\partial x}} \approx-\frac{R M S[\Delta x]_{t-1}}{R M S[\Delta g]_{t}}
</script>
这里的RMS表示均方:
<script type="math/tex; mode=display">
\operatorname{RMS}[g]_{t}=\sqrt{E\left[g^{2}\right]_{t}+\epsilon}
</script>
可以得到:
<script type="math/tex; mode=display">
\Delta x_{t}=-\frac{\operatorname{RMS}[\Delta x]_{t-1}}{\operatorname{RMS}[g]_{t}} g_{t}
</script>
最后的更新公式为
<script type="math/tex; mode=display">
\mathrm{x}_{\mathrm{t+1}}=\mathrm{x}_{\mathrm{t}} + \Delta x_{t}
</script></p>
<blockquote>
<p>优点</p>
</blockquote>
<ol>
<li><strong>无需手动设置学习率</strong>：Adadelta能够自适应地调整学习率，无需手动设置</li>
<li><strong>解决了学习率衰减问题</strong>：由于采用了衰减平均的方式，Adadelta能够解决学习率随时间衰减过快的问题，使得模型能够更好地收敛</li>
<li><strong>不依赖全局学习率</strong>：Adadelta不需要设置全局学习率，因此可以适应不同参数的学习速度需求</li>
<li><strong>对初始学习率不敏感</strong>：Adadelta相对于其他优化器对初始学习率的选择并不敏感，使得模型更具鲁棒性</li>
</ol>
<blockquote>
<p>缺点</p>
</blockquote>
<ol>
<li><strong>存储额外的状态信息</strong>：Adadelta需要保存额外的状态信息(如梯度平方的累积)，增加了存储的开销</li>
<li><strong>算法参数要调整</strong>：Adadelta中的衰减系数<script type="math/tex; ">\rho</script>需要进行适当的调整，不同任务可能需要不同的设置</li>
</ol>
<h3 id="adam">1.4.4 Adam</h3>
<p><code>Adam(Adaptive Moment Estimation)</code>自适应矩估计，是另一种<strong>自适应学习率</strong>的算法，<strong>本质上是带有动量项的Adadelta或RMSprop</strong></p>
<p>是Diederik P. Kingma等人在2014年提出的优化算法，引入了两个参数<script type="math/tex; ">\beta 1</script>和<script type="math/tex; ">\beta 2</script></p>
<blockquote>
<p>思路</p>
</blockquote>
<p>Adam不仅如RMSProp算法那样基于<strong>一阶矩均值</strong>计算适应性参数学习率，它同时还充分利用了<strong>梯度的二阶矩均值</strong>(即<strong>有偏方差</strong>)，适合解决含大规模的数据和参数的优化目标，也适合解决包含高噪声或稀疏梯度的问题，让参数更新时保持稳定</p>
<p><script type="math/tex; mode=display">
\begin{aligned} 

m_{t} & =\beta_{1} m_{t-1}+\left(1-\beta_{1}\right) g_{t} \\ \\

v_{t} & =\beta_{2} v_{t-1}+\left(1-\beta_{2}\right) g_{t}^{2} \\ \\

\hat{m}_{t} & =\frac{m_{t}}{1-\beta_{1}^{t}} \\ \\

\hat{v}_{t} & =\frac{v_{t}}{1-\beta_{2}^{t}} \\ \\

\end{aligned}
</script></p>
<p>其中<script type="math/tex; ">\beta _1</script>控制一阶动量，<script type="math/tex; ">\beta _2</script>控制二阶动量</p>
<p>最终的参数更新公式为
<script type="math/tex; mode=display">
w_{t+1} = w_{t}- \eta \frac{\hat{m}_{t}}{\sqrt{\hat{v}_{t}}+\epsilon} 
</script>
默认值设置<script type="math/tex; ">\alpha=0.001 </script>，<script type="math/tex; "> \beta 1=0.9 </script>，<script type="math/tex; "> \beta 2=0.999 </script>，<script type="math/tex; "> \varepsilon=10-8</script> </p>
<blockquote>
<p>优点</p>
</blockquote>
<ul>
<li><strong>自适应学习率</strong>：Adam通过<strong>自适应地调整每个参数的学习率</strong>，可以有效地应对不同参数的梯度变化情况。这使得它在训练过程中更容易收敛，并且对于大多数任务具有较好的性能，但是需要注意的是它的效果有时候不如SGDM</li>
<li><strong>速度快</strong>：Adam结合了动量方法，能够在训练过程中积累梯度的动量，从而加速参数更新的速度，尤其在具有平坦或稀疏梯度的情况下更加明显</li>
<li>结合了Adagrad善于处理稀疏梯度和RMSprop善于处理非平稳目标的优点</li>
<li><strong>适用性广泛</strong>：也适用于大多非凸优化，适用于大数据集和高维空间</li>
</ul>
<blockquote>
<p>缺点</p>
</blockquote>
<ul>
<li><strong>内存消耗较大</strong>：Adam需要存储每个参数的动量和平方梯度估计，这会占用较大的内存空间，特别是在具有大量参数的深度神经网络中</li>
</ul>
<h3 id="adamax">1.4.5 AdaMax</h3>
<p><code>AdaMax</code>是一种<strong>自适应学习率</strong>优化算法，是Adam优化器的一种<strong>变体</strong></p>
<p>AdaMax使用了梯度的无穷范数来估计梯度的大小，而Adam使用了梯度的二范数(<strong>核心区别</strong>)，变化如下所示
<script type="math/tex; mode=display">
v_{t} = \beta_{2} v_{t-1}+\left(1-\beta_{2}\right) g_{t}^{2}  \longrightarrow v_{t} = \beta_{2} v_{t-1}+\left(1-\beta_{2}\right) |g_{t}|^{p}
</script>
论文中AdaMax的<script type="math/tex; ">p= \infty</script></p>
<blockquote>
<p>为什么是选择了无穷范数</p>
</blockquote>
<p>AdaMax选择了无穷范数(<script type="math/tex; ">\infty</script>范数)是因为在大多数情况下，<script type="math/tex; ">\infty</script>范数具有稳定的行为</p>
<p>对于一些问题，特别是在深度学习中，<script type="math/tex; ">\infty</script>范数可以提供更好的数值稳定性和收敛性</p>
<p>相比于其他范数，<script type="math/tex; ">\infty</script>范数能够更好地控制梯度的最大值，从而减少参数更新的不稳定性</p>
<p>因此，AdaMax选择了<script type="math/tex; ">\infty</script>范数作为其更新规则的一部分，以提高优化算法的稳定性和效果</p>
<h3 id="nadam">1.4.6 Nadam</h3>
<blockquote>
<p><a href="https://paddlepedia.readthedocs.io/en/latest/tutorials/deep_learning/optimizers/nadam.html" target="_blank">深度学习优化策略Nadam</a></p>
</blockquote>
<p><code>Nadam(Nesterov-accelerated Adaptive Moment Estimation)</code>是将Adam与Nesterov加速梯度结合在一起，它对学习率的约束将更强，具备二者的优势，使得此算法在某些问题上的效果更好</p>
<p>Nadam的更新规则与Adam类似，但在计算梯度更新时引入了Nesterov动量项。具体而言，Nadam在计算梯度的移动平均和梯度更新时，使用了Nesterov动量的修正梯度来更新模型参数。这使得Nadam在处理凸优化问题时能够更好地逼近最优解，并且在处理非凸问题时能够更快地收敛</p>
<h3 id="其他优化器">1.4.7 其他优化器</h3>
<p>AdamW（Adam with Weight Decay）： AdamW是对Adam优化器的改进，通过添加权重衰减（Weight Decay）的正则化项来解决权重衰减对Adam优化器的影响。传统的Adam优化器在计算梯度更新时，会将权重衰减项也纳入梯度计算中，导致权重衰减效果不准确。而AdamW在计算梯度更新时将权重衰减项单独处理，使得权重衰减的效果更加准确和稳定</p>
<p>ASGD（Average Stochastic Gradient Descent）： ASGD是一种随机梯度下降法的变体，它通过计算一定数量的随机梯度的平均值来更新模型参数。ASGD使用一个平均模型参数的历史记录，以减小训练过程中参数更新的方差。这样可以使模型的收敛速度更稳定，并且能够在训练过程中逐渐减小学习率，使得模型在训练后期更加趋于收敛</p>
<p>LBFGS（Limited-memory Broyden-Fletcher-Goldfarb-Shanno）： LBFGS是一种基于拟牛顿法的优化算法，用于解决无约束非线性优化问题。它利用函数的一阶导数和二阶导数信息来逼近目标函数的局部二次模型，并通过迭代更新参数来寻找最优解。LBFGS使用有限的内存来存储历史信息，以减少内存消耗。由于它不需要显式计算二阶导数矩阵，LBFGS适用于参数较多的问题，并且通常具有较好的收敛性能</p>
<p>总结：</p>
<ul>
<li>AdamW是对Adam优化器的改进，解决了权重衰减对Adam优化器的影响</li>
<li>ASGD是一种随机梯度下降法的变体，通过平均随机梯度来减小参数更新的方差，提高收敛速度和稳定性</li>
<li>LBFGS是一种基于拟牛顿法的优化算法，通过逼近目标函数的局部二次模型来寻找最优解，具有较好的收敛性能和适用性</li>
</ul>
<h1 id="学习率衰减">2 学习率衰减</h1>
<p>在模型优化中，常用到的几种学习率衰减方法有：分段常数衰减、多项式衰减、指数衰减、自然指数衰减、余弦衰减、线性余弦衰减、噪声线性余弦衰减</p>
<p><a href="https://www.hanspub.org/journal/PaperInformation.aspx?paperID=27016&amp;btwaf=50696508" target="_blank">深度学习优化器方法及学习率衰减方式综述</a> </p>
<p></p><footer class="page-footer"><span class="copyright">Copyright © narutohyc.com 2021 all right reserved，powered by Gitbook</span><span class="footer-modification">该文件修订时间：
2023-09-06 12:58:07
</span></footer><hr/><div id="vcomments"></div><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script>new Valine({el: "#vcomments",appId: 'evyLlP61gQN3G3OM2GQq1rzH-gzGzoHsz',appKey: 'utUrzoiqNaDEGlgr09JL1pXB',placeholder: '欢迎留下评论交流~',avatar: 'wavatar',meta: undefined,pageSize: 15,lang: 'zh-CN',recordIP: false})</script><p></p>
</section>
</div>
<div class="search-results">
<div class="has-results">
<h1 class="search-results-title"><span class="search-results-count"></span> results matching "<span class="search-query"></span>"</h1>
<ul class="search-results-list"></ul>
</div>
<div class="no-results">
<h1 class="search-results-title">No results matching "<span class="search-query"></span>"</h1>
</div>
</div>
</div>
</div>
</div>
</div>
<a aria-label="Previous page: 数据标注工具.md" class="navigation navigation-prev" href="数据标注工具.html">
<i class="fa fa-angle-left"></i>
</a>
<a aria-label="Next page: 深度学习核心之损失函数.md" class="navigation navigation-next" href="深度学习核心之损失函数.html">
<i class="fa fa-angle-right"></i>
</a>
<script src="https://cdn.jsdelivr.net/gh/zztongtong/CDN/js/live2d.min.js"></script><div style="position:absolute; bottom:0; left:0; width:200;"><canvas height="350" id="model_1" width="200"></canvas></div></div>
<script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"abbrlink":36065,"date":"2023/05/26 16:31:14","cover":"https://pic.hycbook.com/i/hexo/post_cover/蕾姆9.webp","title":"深度学习核心之优化器.md","tags":["深度学习","神经网络","优化算法"],"top_img":"https://pic.hycbook.com/i/hexo/post_imgs/蕾姆9.webp","mathjax":true,"categories":["deep_learning"],"description":"深度学习核心之优化器","level":"1.13","depth":1,"next":{"title":"深度学习核心之损失函数.md","level":"1.14","depth":1,"path":"chapters/深度学习核心之损失函数.md","ref":"chapters/深度学习核心之损失函数.md","articles":[]},"previous":{"title":"数据标注工具.md","level":"1.12","depth":1,"path":"chapters/数据标注工具.md","ref":"chapters/数据标注工具.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-sharing","splitter","expandable-chapters-small","anchors","github","github-buttons","donate","sharing-plus","anchor-navigation-ex","mathjax","mermaid-gb3","tbfed-pagefooter","code","search-plus","-lunr","-search","lightbox","theme-comscore","valine","pageview-count","favicon-absolute","copyright-v"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"tbfed-pagefooter":{"copyright":"Copyright © narutohyc.com 2021","modify_label":"该文件修订时间：","modify_format":"YYYY-MM-DD HH:mm:ss"},"github":{"url":"https://github.com/hycBook"},"splitter":{},"sharing-plus":{"qq":false,"all":["facebook","google","twitter","instapaper","linkedin","pocket","stumbleupon"],"douban":false,"facebook":true,"weibo":false,"instapaper":false,"whatsapp":false,"hatenaBookmark":false,"twitter":true,"messenger":false,"line":false,"vk":false,"pocket":true,"google":false,"viber":false,"stumbleupon":false,"qzone":false,"linkedin":false},"code":{"copyButtons":true},"donate":{"alipay":"https://s2.loli.net/2022/03/23/dEYjkaSGXwe7rnu.png","alipayText":"alipay打赏","button":"欢迎打赏","title":"","wechat":"https://s2.loli.net/2022/03/23/WDiTVSamQBJdEA4.png","wechatText":"wechat打赏"},"favicon-absolute":{"appleTouchIconMore":{},"appleTouchIconPrecomposed152":"./chapters/res/other/favicon.ico","appleTouchIconPrecomposedMore":{},"favicon":"./chapters/res/other/favicon.ico"},"copyright-v":{"copyProtect":false,"enableFooter":false,"site":"https://dl.hycbook.com","author":"narutohyc","website":"深度学习知识驿站","image":"https://s2.loli.net/2022/03/24/pbMd1BCgUNzi7mG.png"},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"mermaid-gb3":{},"anchor-navigation-ex":{"associatedWithSummary":true,"float":{"floatIcon":"fa fa-navicon","level1Icon":"","level2Icon":"","level3Icon":"","showLevelIcon":false},"mode":"float","multipleH1":true,"pageTop":{"level1Icon":"","level2Icon":"","level3Icon":"","showLevelIcon":false},"printLog":false,"showGoTop":true,"showLevel":false},"lightbox":{"jquery":true,"sameUuid":false},"theme-comscore":{},"pageview-count":{},"github-buttons":{"buttons":[{"user":"hycBook","repo":"bk_dl_page","type":"star","size":"small","count":true}]},"mathjax":{"forceSVG":false,"version":"2.6-latest"},"expandable-chapters-small":{},"sharing":{"qq":true,"all":["google","facebook","weibo","twitter","qq","qzone","linkedin","pocket"],"douban":true,"facebook":true,"weibo":true,"instapaper":false,"whatsapp":false,"hatenaBookmark":false,"twitter":true,"messenger":false,"line":false,"vk":false,"pocket":false,"google":true,"viber":false,"stumbleupon":false,"qzone":true,"linkedin":false},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":true},"anchors":{},"valine":{"avatar":"wavatar","lang":"zh-CN","pageSize":15,"placeholder":"欢迎留下评论交流~","recordIP":false,"appId":"evyLlP61gQN3G3OM2GQq1rzH-gzGzoHsz","appKey":"utUrzoiqNaDEGlgr09JL1pXB"},"search-plus":{}},"theme":"default","author":"narutohyc","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"深度学习相关学习记录","language":"zh-hans","mathjax":{"forceSVG":true},"links":{"sidebar":{"书籍主页":"https://study.hycbook.com"}},"gitbook":"*","description":"记录 深度学习 的学习和一些技巧的使用"},"file":{"path":"chapters/深度学习核心之优化器.md","mtime":"2023-09-06T12:58:07.441Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2023-09-06T12:58:59.269Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
<canvas class="fireworks"></canvas><script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script></div>
<script src="../gitbook/gitbook.js"></script>
<script src="../gitbook/theme.js"></script>
<script src="../gitbook/gitbook-plugin-splitter/splitter.js"></script>
<script src="../gitbook/gitbook-plugin-expandable-chapters-small/expandable-chapters-small.js"></script>
<script src="../gitbook/gitbook-plugin-github/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-github-buttons/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-donate/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-sharing-plus/buttons.js"></script>
<script src="https://cdn.mathjax.org/mathjax/2.6-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="../gitbook/gitbook-plugin-mathjax/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-mermaid-gb3/book/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-code/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-search-plus/jquery.mark.min.js"></script>
<script src="../gitbook/gitbook-plugin-search-plus/search.js"></script>
<script src="../gitbook/gitbook-plugin-lightbox/js/lightbox.min.js"></script>
<script src="../gitbook/gitbook-plugin-pageview-count/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-copyright-v/plugin.js"></script>
<script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
<script src="../gitbook/gitbook-plugin-theme-comscore/test.js"></script>
<script src="../gitbook/gitbook-plugin-mermaid-gb3/mermaid/mermaid.min.js"></script>
</body>
</html>
